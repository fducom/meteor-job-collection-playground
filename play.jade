//-###########################################################################
//-  Copyright (C) 2015 by Vaughn Iverson
//-  meteor-job-collection-playground is free software released under the MIT/X11 license.
//-  See included LICENSE file for details.
//-###########################################################################

head
  title meteor-job-collection-playground

body

template(name="master")
  div.ui.container
     +top
     +yield "jobContent"
     +yield "workerContent"

template(name="top")
  div.ui.segment
    h2.ui.header job-collection Playground App
    unless currentUser
      div.ui.info.message
        p
          | You are currently in the public playground, create
          | an account and sign in to have a private space.
    div.loginTemp
      +loginButtons align="right"

template(name="workerPanel")
  div.ui.segment
    h3.ui.header Local worker
    if status
      p Status: 
        div.ui.small.teal.label #{status}% complete
      p Job: #{id}
      button.negative.ui.button Fail this job
    else
      p Status:
        div.ui.small.grey.label Idle

template(name="newJobInput")
  div.ui.raised.segment
    h3.ui.header Create a new repeating job
      | using Later.js
      a(target="_blank" href="https://bunkat.github.io/later/parsers.html#text")
        | text parser input,
      | or a
      a(target="_blank" href="http://en.wikipedia.org/wiki/Cron#CRON_expression")
        | CRON expression
      |:
    p
    form.ui.form
      div.field
        label When should it run? 
          span.text-muted (all times are UTC):
        div.ui.fluid.input
          input(id="inputLater" placeholder="e.g. 'every 5 minutes' or '*/5 * * * *'")
          if inputReady
            button#newJob.ui.green.right.labeled.icon.button
              i.wait.icon
              | Create new job
          else
            button.ui.right.icon.button
              i.remove.circle.icon
    p
    if inputReady
      table.ui.celled.table
        thead
          tr
            th
              | Next 3 runtimes:
        tbody
          each nextTimes
            tr
              td
                | #{.}

template(name="jobControls")
  //- div.ui.segment
  div.ui.equal.width.stackable.grid
    //- div.ui.five.buttons
    div.column
      button.ui.green.fluid.labeled.icon.button.clear-completed
        i.checkmark.icon
        | Clear Completed
    div.column
      button.ui.fluid.labeled.icon.button.pause-queue
        i.pause.icon
        | Pause all
    div.column
      button.ui.teal.fluid.labeled.icon.button.restart-queue
        i.repeat.icon
        | Restart all
    div.column
      button.ui.yellow.fluid.labeled.icon.button.cancel-queue
        i.ban.icon
        | Cancel all
    div.column
      button.ui.red.fluid.labeled.icon.button.remove-queue
        i.remove.icon
        | Remove all

template(name="jobTable")
  div.ui.segment
    +newJobInput
    div.ui.raised.segment
      h3.ui.header Job Collection
      div.ui.basic.segment
        u Fine print:
        | Jobs only run when a client is connected. This is because all "work" in this demo is
        | performed in the client code. If you close or reload your browser page while a job is
        | running (and your client was the one working on the job) then that job will not complete,
        | and after a few minutes a "reaper" job on the server will notice and "auto-fail" the
        | job so it can be retried later. Completed and cancelled jobs are also automatically removed
        | by a "cleanup" job on the server after a short period of time. If you are not signed in,
        | then the job collection you see below is being shared with other public users and will
        | update "live" with their actions. In this demo when you create a new repeating job, all
        | preexisting running or waiting jobs of that type are automatically cancelled by the server.

      +jobControls

      table.ui.celled.striped.table
        thead
          tr
            th Type
            th Id
            th Run
            th Updated
            th Attempts
            th Repeats
            th Status
            th Actions
        tbody
          each jobEntries
            +jobEntry
          else
            tr
              td(colspan="20" align="center")
                span.text-info No jobs in collection...

template(name="pauseButton")
  button.ui.tiny.icon.button.pause-job(data-content="Pause Job" data-variation="inverted")
    i.pause.icon

template(name="removeCompletedButton")
  button.ui.tiny.green.icon.button.remove-job(data-content="Remove Job" data-variation="inverted")
    i.checkmark.icon

template(name="resumeButton")
  button.ui.tiny.active.icon.button.resume-job(data-content="Resume Job" data-variation="inverted")
    i.play.icon

template(name="restartButton")
  button.ui.tiny.teal.icon.button.restart-job(data-content="Restart Job" data-variation="inverted")
    i.repeat.icon

template(name="rerunButton")
  button.ui.tiny.blue.icon.button.rerun-job(data-content="Rerun Job" data-variation="inverted")
    i.refresh.icon

template(name="cancelButton")
  button.ui.tiny.yellow.icon.button.cancel-job(data-content="Cancel Job" data-variation="inverted")
    i.ban.icon

template(name="removeNoncompletedButton")
  button.ui.tiny.red.icon.button.remove-job(data-content="Remove Job" data-variation="inverted")
    i.remove.icon

template(name="jobEntry")
  tr
    with doc
      td #{type}
      td #{jobId}
      td(class="#{futurePast}") #{runAt}
      td #{lastUpdated}
      td #{retried} / #{numRetries}
      td #{repeated} / #{numRepeats}
      td
        if running
          div.ui.tiny.indicating.progress(data-percent="#{progress.percent}")
            div.bar(style="transition-duration: 100ms; width: #{progress.percent}%;")
            div.label Running #{progress.percent}%
        else
          div.ui.medium.label(class="#{statusBG}") #{status}
      td.button-column
        if pausable
          +pauseButton
        if resumable
          +resumeButton
        if restartable
          +restartButton
        if rerunable
          +rerunButton
        if cancellable
          +cancelButton
        if removable
          if rerunable
            +removeCompletedButton
          else
            +removeNoncompletedButton
